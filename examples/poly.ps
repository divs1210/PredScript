// ==================================
// new predicates
// ==================================
interface isEven;
interface isOdd;

function isEven(x: isInt): isBool {
    x % 2 == 0
}
__AS__(isPred, isEven);
derive(isInt, isEven);


function isOdd(x: isInt): isBool {
    !isEven(x)
}
__AS__(isPred, isOdd);
derive(isInt, isOdd);


// ==================================
// an increment function
// ==================================
interface inc;

function inc(x: isInt): isInt {
    x + 1
}

// it can now be overridden
// for our new predicates!

function inc(x: isEven): isOdd {
    // integer addition
    // hard casted to isOdd
    // hard casts don't check
    // before casting
    AS(isOdd, x + 1)
}

function inc(x: isOdd): isEven {
    // integer addition
    // hard casted to isEven
    // hard casts don't check
    // before casting
    AS(isEven, x + 1)
}

let int: isInt = 1;
assert(int.inc == 2);
assert(int.inc.type == isInt);

let even: isEven = AS(isEven, 2);
assert(even.inc == 3);
assert(even.inc.type == isOdd);

let odd: isOdd = AS(isOdd, 3);
assert(odd.inc == 4);
assert(odd.inc.type == isEven);