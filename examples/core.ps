interface spy;

interface map;
interface zip;
interface every;

interface gen_isFnOf;
interface gen_isListOf;
interface gen_isVector;
interface gen_isTuple;


// useful for debugging
function spy(x: isAny, tag: isString): isAny {
    println(tag + ": " + x)
    x
}


// not well-typed map
// will stack overflow for large lists
// we need loops / lazy seqs / stackless impl
function map(xs: isList, f: isFn): isList {
    if (isEmpty(xs))
        List()
    else
        xs
        .slice($this, 1)
        .map($this, f)
        .unshift($this, f(xs[0]))
}


// not well-typed zip
// we don't have and / or yet ü§¶üèΩ‚Äç‚ôÇÔ∏è
// assuming both are of equal length
function zip(xs: isList, ys: isList): isList {
    if (isEmpty(xs))
        List()
    else
        xs
        .slice($this, 1)
        .zip($this, slice(ys, 1))
        .unshift($this, List(xs[0], ys[0]))
}


// well typed every
function every(xs: isList, f: isPred): isBool {
    if (isEmpty(xs))
        true
    else if (f(xs[0]))
        xs
        .slice($this, 1)
        .every($this, f)
    else
        false
}


// generic lists
memoized function gen_isListOf(t: isPred): isPred {
    interface isListOf<t>;

    function isListOf(obj: isList): isBool {
        obj.every($this, AS(isPred, (x) => isA(t, type(x))))
    }
    
    derive(isList, isListOf);

    isListOf
}


// vectors are lists of fixed size
memoized function gen_isVector(elementType: isPred, vSize: isInt): isPred {
    let isParentType: isPred = gen_isListOf(elementType);

    interface isVector<elementType, vSize>;

    function isVector(obj: isList): isBool {
        isVector(as(isParentType, obj))
    }

    function isVector(obj: isParentType): isBool {
        obj.size == vSize
    }

    derive(isParentType, isVector);

    isVector
}


let isListOfPreds: isPred = gen_isListOf(isPred);


// tuples are vectors of mixed types
memoized function gen_isTuple(preds: isList): isPred {
    gen_isTuple(as(isListOfPreds, preds))
}

memoized function gen_isTuple(preds: isListOfPreds): isPred {
    let isParentType: isPred = gen_isVector(isAny, size(preds));

    interface isTuple<preds>;

    function isTuple(obj: isList): isBool {
        isTuple(as(isParentType, obj));
    }

    function isTuple(obj: isParentType): isBool {
        obj
        .map($this, type)
        .zip($this, preds)
        .every($this, AS(isPred, (pair) => {
            let isActual: isPred   = pair[0];
            let isExpected: isPred = pair[1];
            isA(isExpected, isActual);
        }))
    }

    derive(isParentType, isTuple);

    isTuple
}


// well-typed fns
memoized function gen_isFnOf(argTypes: isList, retType: isPred): isPred {
    gen_isFnOf(as(isListOfPreds, argTypes), retType);
}

memoized function gen_isFnOf(argTypes: isListOfPreds, retType: isPred): isPred {
    interface isFnOf<argTypes, retType>;

    function isFnOf(f: isFn): isBool {
        isImplementedFor(f, argTypes, retType)
    }

    derive(isFn, isFnOf);

    isFnOf
}


// complex numbers (test)
// ======================
let isComplexNumber: isPred = gen_isTuple(List(isReal, isReal));

function add(x: isComplexNumber, y: isComplexNumber): isComplexNumber {
    List(
        x[0] + y[0],
        x[1] + y[1]
    ).AS(isComplexNumber, $this)
}

function str(x: isComplexNumber): isString {
    let im:  isReal   = x[1];
    let sym: isString = if (im < 0) " - " else " + ";

    "(" + x[0] + sym + abs(im) + "i)"
}

let c1: isComplexNumber = as(isComplexNumber, List(1, 2));
let c2: isComplexNumber = as(isComplexNumber, List(1, -5));
let c3: isComplexNumber = c1 + c2;

println(c3);


// well-typed map (test)
// =====================
interface gen_map;

memoized function gen_map(x: isPred, y: isPred): isFn {
    let isListOfX:  isPred = gen_isListOf(x);
    let isListOfY:  isPred = gen_isListOf(y);
    let isFnOfXToY: isPred = gen_isFnOf(List(x), y);
    let dyn_map:    isFn   = map;

    interface map<x, y>;

    function map(xs: isListOfX, f: isFnOfXToY): isListOfY {
        dyn_map(xs, f)
        .AS(isListOfY, $this)
    }

    map
}


let isListOfInts:      isPred = gen_isListOf(isInt);
let isFnOfIntToString: isPred = gen_isFnOf(List(isInt), isString);
let mapIntToString:    isFn   = gen_map(isInt, isString);

let ints: isListOfInts = List(0, 1, 2, 3, 4).as(isListOfInts, $this);
let intToString: isFnOfIntToString = as(isFnOfIntToString, str);

println(mapIntToString(ints, intToString));